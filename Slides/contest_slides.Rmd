---
title: Contest package in R
author: Andrea Blasco
institute: ablasco@fas.harvard.edu
date: \today
output: 
  beamer_presentation:
    slide_level: 2
    template: ~/Templates/Pandoc/boyd.beamer
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```

# What does the `contest` package do?

## What does the `contest` package do?

* This package **solves** an extension of the [Moldovanu and Sela (2001)](https://www.aeaweb.org/articles?id=10.1257/aer.91.3.542)'s contest model that encompasses race contests (the first wins) and tournament contests (the best wins).

* It provides an easy way to **compute equilibria** using numerical integration when the model does not allow for explicit solutions (which happens many times)

* Helps running **Monte Carlo studies** to find optimal contest design (number of competitors, prize structure, deadlines, entry requirements, etc.)

* Facilitates **estimation** of model's parameter from real data

## Installation

The latest version of the package is on GitHub. 

First, you need to install and invoke the `devtools` package.

```r
install.packages('devtools')
library(devtools)
```

Second, you need to install the package from the repo `"mrblasco/contest"` with the following command 

```r
install_github("mrblasco/contest")
```


## The MS (2001)'s contest model

* It is an "all-pay" contest model: everyone incurs a cost from effort that is paid before uncertainty about rivals' actions is fully realized

* Players compete for $k=1,..., q$ prizes of decreasing value $v_1\geq v_2\geq ...\geq v_q$ with $\sum v_k = 1$.

* Decide simultaneously completion time $t$ and performance $y$ (or equivalently: speed $s$ and performance $y$)

* Players have ability $a\sim F$ on a bounded interval.

* Costs are multiplicative: $c(a, y, t)$ with elasticities $\alpha<0$, $\beta>0$, and $\gamma<0$.  


## The `contest()` function

Arguments:

* `x`: a vector of realized abilities
* `n`: the number of competitors in the contest
* `type`: either a race or a tournament
* `prize`: a vector with prizes for 1st and 2nd place (prizes higher than 2nd place are ignored)
* `elasticity`: a vector with cost elasticities
* `p, d`: distribution and density functions for abilities
* `xlim`: interval for ability distribution
* `deadline, target`: parameters of the contest


## Outcomes

Computes the symmetric equilibrium via `R` builtin numerical integration  tool `integrate()`.

Values:

* `ability`: a vector of input abilities
* `score`: a vector of equilibrium performances
* `timing`: a vector of equilibrium completion times
* `utility`: a vector of expected payoffs
* `marginal.type`: ability level below which it is not optimal to enter the contest
* `params:` list of contest parameters

## Usage
 
```r
library(contest)
ability <- runif(10) # uniformly distributed (default)
contest(
	sort(ability)
	, n=10 # 10 players	
	, prize=c(1,0) # Winner-takes-all
	, deadline=10 # Time upper-limit
	, target=0.5 # Performance lower-limit
)	
```

## Example: compare ability distributions

```{r, echo=FALSE}
par(mfrow=c(2, 4))
x <- seq(0, 1, length=50)

# Uniform
curve(dunif, xlab="Ability ~ Uniform", ylab="density")
title("Ability distribution")
plot(contest(x, n=4, p=punif,d=dunif), pch=16, cex=.5)

# Beta
curve(dbeta(x, shape1=2, shape2=5), xlab="Ability ~ Beta(2, 5)", ylab="density")
title("Ability distribution")
plot(contest(x, n=4, p=pbeta,d=dbeta, shape1=2,shape2=5), pch=16, cex=.5)
```


## Example: compare races and tournaments

```{r, echo=FALSE}
library(contest)
x <- seq(0, 1, length=50)
race <- contest(x, n=4, type='race', prize=c(1,0), deadline=10, target=0.5
		, p=pbeta,d=dbeta, shape1=2,shape2=5, elasticity=c(-1,2,-0.5))
tournament <- contest(x, n=4, type='tournament', prize=c(1,0), deadline=10, target=0.5
		, p=pbeta,d=dbeta, shape1=2,shape2=5, elasticity=c(-1,2,-0.5))

par(mfrow=c(2, 3))
plot(tournament, pch=16, cex=.5)
plot(race, pch=16, cex=.5)
```


# Monte Carlo Experiments

## Monte Carlo Method

- Random sampling from true distribution to compute expected values (e.g., contest designer's revenues)

- Let $y^*(\cdot)$ $t^*(\cdot)$ denote the equilibrium functions for performance and time

- The expected average (equilibrium) performance under $F$ is

$$
	E_F[y*] = \int_{0}^1 y^*(x) dF(x)
$$

- Let $a=(a_1, a_2, ..., a_s)$ be $s$ realization of abilities under $F$

- By the law of large numbers, the sample mean computed on several replica of $a$ converges (in distribution) to the expected value


## Example: expected top performance

In equilibrium, the expected top performance under $F$ is

$$
	\theta = E_{F}[\max\{y_1^*,y_2^*,...,y_n^*\}] = E_{F_{(n)}}[y^*]
$$

where $F_{(n)}$ is the distribution of the $n$-th order statistics of the $y$'s.

Monte Carlo estimation:

- Simulate $s$ abilities $a_1, a_2,...,a_s$ from $F_{(n)}$

$$
	\hat\theta = \frac{1}{s}\sum y^*(a_i) 
$$


## Example: expected top performance in R

```{r}
mc.contest <- function(R, n=10, ...) {
	a <- runif(R*n) # abilities
	a.max <- tapply(a, rep(1:R, each=n), max)
	scores <- contest(a.max, n=n, ...)$score
	mean(scores) # Estimated expected top performance
}
mc.contest(R=100, type='tournament')
``` 

## How many replications?

```{r replications, echo=FALSE}
nsim <- seq(50, 1000, by=100)
out <- sapply(nsim, function(x) replicate(50, mc.contest(R=x, type='tournament')))
colnames(out) <- nsim
boxplot(out, xlab="Monte Carlo replications", ylab="Estimates")
```

# Optimal contest design

## Contest designer's revenues

Imagine timing is not an issue, then only top expected performance matters:

$$
	\pi_{cd} = E_{F_{(n)}}[y^*] 
$$

* Can CDs increase revenues by imposing a minimum target performance?
* What is the optimal target?

##  Optimal Target in a Tournament

```{r optim-tournament}
f <- function(x) {
	mc.contest(R=200, n=10, type='tournament', target=x)
}
# optimal target
optimize(f, interval=c(0, 1), maximum=TRUE) 
```

## Optimal Target in a Race

```{r optim-race}
f <- function(x) {
	mc.contest(R=200, n=10, type='race', target=x)
}
optimize(f, interval=c(0, 1), maximum=TRUE) 
```

## Races vs tournaments

```{r, echo=FALSE}
x <- seq(0.6, 1, length=200)
tournament <- contest(x, n=10, type='tournament', target=0.189)
race <- contest(x, n=10, type='race', target=0.49)

par(mfrow=c(1, 2))
plot(x, tournament$score, pch=16, cex=.5, type='b', xlab="ability", ylab="Score")
points(x, race$score, pch=16, cex=.5, type='b', col=2)
plot(x, tournament$timing, pch=16, cex=.5, type='b', xlab="ability", ylab="Timing")
points(x, race$timing, pch=16, cex=.5, type='b', col=2)
```

## The optimal allocation of prizes in tournaments

MS (2001) proves that:

* With **linear** cost functions, "it is optimal to allocate the entire prize sum to a single first prize."

* "With **convex** cost functions, the beneficial effect of the second prize on middle- and low- ability players is amplified, while the advantage of having one prize (which strongly motivates high-ability contestants) is decreased."

* "Exactly the opposite occurs for **concave** cost functions."


## The optimal allocation of prizes in R

```{r optim-prize}
# Convex costs, e.g., x^2
f <- function(x) {
	mc.contest(R=1e3, n=10, prize=c(x, 1-x), elasticity=c(-1, 2, -1))
}
optimize(f, interval=c(0.5, 1), maximum=TRUE)$maximum

# Linear costs, e.g., x^1
f <- function(x) {
	mc.contest(R=1e3, n=10, prize=c(x, 1-x), elasticity=c(-1, 1, -1))
}
optimize(f, interval=c(0.5, 1), maximum=TRUE)$maximum
```


# Estimation

## Estimating an unknown ability distribution 

* The ability distribution $F(\cdot; \theta)$ is known up to a paramter $\theta$ that we want to estimate from the data

* Observe a sample of $y_1,...,y_s$  from $F_{Y}$


* Let $\mathbf{1}_{y_0}(x)$ denote an indicator function that is 1 if $x>y_0$. 

* The likelihood function is

$$
	\mathcal{L} = \prod_{i=1}^s F_{Y}(y_0)^{1-\mathbf{1}_{y_0}(y_i)}f_{Y}(y_i)^{\mathbf{1}_{y_0}(y_i)}
$$

\begin{align*}
	\log\mathcal{L} & = \sum_{i=1}^s [1-\mathbf{1}_{y_0}(y_i)] \log F_{Y}(y_0) 
										+ \mathbf{1}_{y_0}(y_i) \log f_{Y}(y_i)\\
			 & = n_0 \log F_{Y}(y_0) +  \sum_{i=1}^s \mathbf{1}_{y_0}(y_i) \log f_{Y}(y_i)
\end{align*}

## Estimating an unknown ability distribution, cont'd

At equilibrium, we have $y_i = y^*(a_i)$ and $y_i\leq y_0 \iff a_i \leq a_0(\theta)$

* Let $\phi$ denote the inverse of $y^*$

* Using a change of variable, we have 
\begin{align*}
	\log\mathcal{L} & = n0 \log F(\phi(y_0)) 
										+ \sum_{i=1}^s \mathbf{1}_{y_0}(y_i) \log f(\phi(y_i)) \phi^\prime(y_i) \\
									& \text{(by the chain's rule)} \\
									& = n0 \log F(\phi(y_0)) 
										+ \sum_{i=1}^s \mathbf{1}_{y_0}(y_i) \log f(\phi(y_i)) \frac{1}{y^{*\prime}(\phi(y_i))}\\
									& = n0 \log F(a_0) 
										+ \sum_{i=1}^s \mathbf{1}_{y_0}(y_i) \log f(a_i) \frac{1}{y^{*\prime}(a_i)}
\end{align*}

## First derivative of bid function

Whe $a>a_0$, the equilibrium score: 

$$
	y^*(a) = \left[ y_0^\beta + v_1 \int_{a_0}^a g_1(x)dx + v_2 \int_{a_0}^a g_2(x)dx \right]^{1/\beta}
$$

$$
		y^{*\prime}(a) = \frac{1}\beta (y^*(a))^{1-\beta} \left[ v_1 g_1(a) + v_2 g_2(a) \right]
$$

```{r}
contest(seq(0, 1, length=20), n=4)$deriv
```

## Data generating process in R

Assume we observe $m$ replications of contests with $j$ competitors

```{r}
# Data simulator
sim.contest <- function(m, j, type="tournament", ...) {
	n <- m * j  # total obs
	x <- rbeta(n, ...) # sim abilities
	out <- contest(x, n=j, type, p=pbeta, d=dbeta, ...)
	y <- out$score # simulated scores
	return(list(y=y, n=j, type='tournament', param=out))
}
#dat <- sim.contest(m=20, j=4, shape1=2, shape2=5)
```

## Define $\log \mathcal{L}$ in R

```{r}
# Log-likelihood
loglik <- function(par, data)  {
	y <- data$y; n <- data$n; type <- data$type # parse data
	x.seq <- seq(0, 1, length=100) # Evaluation "grid"
	out <- contest(x.seq, n=n, type=type, p=pbeta, d=dbeta
					, shape1=par[1], shape2=par[2])
	a0 <- out$marginal.type # Marginal type given par
	n0 <- sum(y==0)
	# Instead of inverting the function, pick nearest 
	# score to identify an ability in the grid
	index <- out$score>0 			# Only positive scores
	ystar <- out$score[index] # Positive bids
	deriv  <- out$deriv[index] # Derivative
	xstar	<- x.seq[index] 		# Abilities higher than marginal
	y.obs <- y[y>0] 					# Only positive y's
	near <- sapply(y.obs, function(x) which.min(abs(ystar - x)))
	ll <- n0 * pbeta(a0, shape1=par[1], shape2=par[2], log=TRUE) + 
	sum(dbeta(xstar[near], shape1=par[1], shape2=par[2], log=TRUE) / deriv[near])
	return(ll/length(y))
}
```

## Check concavity ... argh!!!

```{r, echo=FALSE}
set.seed(1)
theta <- 5
dat <- sim.contest(m=30, j=4, shape1=2, shape2=theta)
par.grid <- seq(1.01, 8, length=50)
ll <- sapply(par.grid, function(x) loglik(c(2, x), dat))
plot(par.grid, ll, ylab="Log Likelihood", xlab='theta', pch=16, cex=.5)
abline(v=theta, lty=3, col=2)
```

## Check concavity 3

```{r, echo=FALSE}
set.seed(1)
theta <- 5
dat <- sim.contest(m=30, j=4, shape1=2, shape2=theta)
par.grid <- seq(1.01, 8, length=50)
ll <- sapply(par.grid, function(x) loglik(c(2, x), dat))
plot(par.grid, ll, ylab="Log Likelihood", xlab='theta', pch=16, cex=.5)
abline(v=theta, lty=3, col=2)
```


## Check concavity ... issues

\columnsbegin
\column{.5\textwidth}


```{r, echo=FALSE, fig.cap="The non-monotonicity issue"}
out <- curve(dbeta(x, shape1=2, shape2=1), ylim=c(0, 4))
text(out$x[90], out$y[90], sprintf("theta=%i",1), pos=2, cex=.8)
for (i in 2:8) {
	out <- curve(dbeta(x, shape1=2, shape2=i), add=TRUE, lty=2)
	text(out$x[50+i*2], out$y[50+i*2], sprintf("theta=%i",i), pos=2, cex=.8)
}
```


\column{.5\textwidth}

```{r, echo=FALSE, fig.cap="The highest possible bid"}
highest <- sapply(1:8, function(x)contest(1, n=4, p=pbeta, d=dbeta, shape1=2, shape2=x)$score)
plot(1:8, highest, type="o", xlab="theta", ylim=c(dat$param$params$target, max(highest)))
abline(h=max(dat$y), lty=2, col=2)
abline(h=dat$param$params$target, lty=3)
legend("topright",c("Obs. highest bid", "Target"), lty=2:3, col=c(2, 1), bty='n')
```

\columnsend


## Estimator 

Compute Mean Squared Error $n^{-1} \sum\theta - \hat\theta_i$

```
# Slow implementation ... simulate first and then compute
ll2 <- function(x, data) loglik(c(2, x), data)
n800 <- replicate(100, {
	dat <- sim.contest(m=20, j=4, shape1=2, shape2=theta)
	optimize(f=ll2, data=dat, lower=2, upper=5.6, maximum=TRUE)$maximum
})
n400 <- replicate(100, {
	dat <- sim.contest(m=10, j=4, shape1=2, shape2=theta)
	optimize(f=ll2, data=dat, lower=2, upper=5.6, maximum=TRUE)$maximum
})
boxplot(theta, n400, n800, names=c("Theta","hatTheta(400)","hatTheta(800)"))
# mse800 <- mean((theta - n800)^2)
# mse400 <- mean((theta - n400)^2)

```









